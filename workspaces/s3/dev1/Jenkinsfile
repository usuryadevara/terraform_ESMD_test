pipeline {
  agent {
    kubernetes {
      yamlFile 'kubernetes_docker.yml'
    }
  }

    options { //Defining the options for the Job
        buildDiscarder(logRotator(numToKeepStr: '15'))
        timeout(time:30, unit: 'MINUTES')
        parallelsAlwaysFailFast()
    } 

    parameters {
        choice(choices: ' \ndev1\nval1',description: 'Environment',name: 'ENVIRONMENT')
        //string(name: 'environment', defaultValue: 'dev', description: 'Workspace/environment file to use for deployment')
        booleanParam(name: 'autoApprove', defaultValue: false, description: 'Want to auto run apply after Generating plan?')
    }
    
    environment {
        /*If TF_IN_AUTOMATION is set to any non-empty value, Terraform adjusts its output to avoid suggesting specific commands to run next. 
        This can make the output more consistent and less confusing in workflows where users don't directly execute Terraform commands, 
        like in CI systems or other wrapping applications. This is a purely cosmetic change to Terraform's human-readable output, 
        and the exact output differences can change between minor Terraform versions.*/
        TF_IN_AUTOMATION      = '1'
    }

    stages {
        stage('tf-init & tf-Plan') {
            steps {
                container('docker') {
                    script {
            currentBuild.displayName = params.version
              if ("${params.ENVIRONMENT}" == 'dev1') {
                  env.ACCOUNT_ID = "818345503029"
                  env.ECS_CLUSTER_NAME = "dev-esmd-az"
              } else if ("${params.ENVIRONMENT}" == 'val') {
                  env.APPROVAL = input message: 'Approval required for Val Environment', ok: 'Release!'/*,submitter: "esmddevsecops@unissant.com"*/
                  env.ACCOUNT_ID = "174393543144"
                  env.ECS_CLUSTER_NAME = "tf-val-esmd-az"
              } else {
                  echo 'Input correct AWS account'
              }
sh '''
# Generate the credentials file
echo Runnign in AWS Account $ACCOUNT_ID
aws sts assume-role \
--role-arn arn:aws:iam::${ACCOUNT_ID}:role/delegatedadmin/developer/esmd_devops_cbc_master_role \
--role-session-name session \
--output text \
--query Credentials \
> /tmp/role-creds.txt
cat > .aws-creds <<EOF
[default]
aws_access_key_id = $(cut -f1 /tmp/role-creds.txt)
aws_secret_access_key = $(cut -f3 /tmp/role-creds.txt)
aws_session_token = $(cut -f4 /tmp/role-creds.txt)
EOF

# Copy the credentials file to its default location and remove variable from
# the shell environment to assume role in the ADO account.
mkdir -p $HOME/.aws
cp -v .aws-creds $HOME/.aws/credentials
unset AWS_WEB_IDENTITY_TOKEN_FILE

# Run AWS command to test the assume role. 
aws sts get-caller-identity
#aws s3 ls
'''
ansiColor('xterm') {
sh ("""
    cd modules/s3/
    terraform init -backend-config ../../workspaces/s3/${params.ENVIRONMENT}/${params.ENVIRONMENT}-backend-config.tfvars
    terraform workspace new ${params.ENVIRONMENT} || terraform workspace select ${params.ENVIRONMENT}
    terraform plan -out tfplan -var-file=../../workspaces/s3/${params.ENVIRONMENT}/terraform.tfvars
    terraform show -no-color tfplan > tfplan.txt
""")
//sh """cd modules/s3/ && terraform init -backend-config ../../workspaces/s3/${params.ENVIRONMENT}/${params.ENVIRONMENT}-backend-config.tfvars"""
//sh """cd modules/s3/ && terraform workspace new ${params.ENVIRONMENT} || terraform workspace select ${params.ENVIRONMENT}"""
//sh """cd modules/s3/ && terraform plan -out tfplan -var-file=../../workspaces/s3/${params.ENVIRONMENT}/terraform.tfvars"""
//sh """cd modules/s3/ && terraform show -no-color tfplan > tfplan.txt"""
}
                    }
                }
            }
        }

        stage('Approval') {
            when {
                not {
                    equals expected: true, actual: params.autoApprove
                }
            }

            steps {
                container('docker') {
                    script {
                    def plan = readFile 'modules/s3/tfplan.txt'
                    input message: "Do you want to apply the plan?",
                    parameters: [text(name: 'Plan', description: 'Please review the plan', defaultValue: plan)]
                    }
                }
            }
        }

        stage('tf-Apply') {
            steps {
                container('docker') {
                    ansiColor('xterm') {
                    sh ("""
                        cd modules/s3/
                        terraform apply -input=false tfplan
                    """)
                    }
                }
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'modules/s3/tfplan.txt'
        }
    }
}